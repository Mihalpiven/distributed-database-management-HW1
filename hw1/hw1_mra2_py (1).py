# -*- coding: utf-8 -*-
"""hw1_mrA2_322479387_207039199_208197814.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lTyZAzNXrDUzC_DD3oYaCEfKwrUWak1c
"""

!pip install MRJob

# Commented out IPython magic to ensure Python compatibility.
# %%file hw1_mrA2_322479387_207039199_208197814.py
# import csv
# from mrjob.job import MRJob
# from mrjob.step import MRStep
# 
# class MRApproved(MRJob):
# 
#     def steps(self):
#         return [
#             MRStep(mapper=self.mapper, reducer=self.reducer),
#             MRStep(mapper=self.score_mapper, reducer=self.best_score)
#         ]
# 
#     def mapper(self, _, line):
#         # parse CSV and skip header
#         try:
#             row = next(csv.reader([line]))
#         except Exception:
#             return
#         if row[0] == 'title':
#             return
# 
#         # extract fields
#         try:
#             title     = row[0]
#             genres    = [g.strip() for g in row[2].split(',') if g.strip()]
#             air_date  = row[3]
#             raw_time  = row[4]
#             air_time  = int(raw_time.replace(':', ''))
#         except Exception:
#             return
# 
#         # apply letter-based criteria (3 & 4)
#       #changing for lowercase so we will deal with case insensitive
#         tl = title.lower()
#         #criteria 4
#         if any(c in tl for c in ('a', 'b')):
#             return
#         #criteria 3
#         if sum(tl.count(c) for c in ('p', 'w', 'm')) < 2:
#             return
# 
#         # apply time-window criterion (1)
#         if air_time < 133000 or air_time >= 163000:
#             return
# 
#         # passed criteria 1,3,4: emit date and genre tags
#         approved_set = {'Reality', 'Community', 'Adventure', 'Animated'}
#         yield title, ('date', air_date)
#         for g in genres:
#             yield title, ('all_genre', g)
#             if g in approved_set:
#                 yield title, ('approved_genre', g)
# 
#     def reducer(self, title, values):
#         all_genres      = set()
#         approved_genres = set()
#         dates           = set()
# 
#         for tag, val in values:
#             if tag == 'all_genre':
#                 all_genres.add(val)
#             elif tag == 'approved_genre':
#                 approved_genres.add(val)
#             elif tag == 'date':
#                 dates.add(val)
# 
#         # enforce criteria 2: at least one approved genre AND at least one date
#         #because of the condition we put in the mapper, we will get only the dates that answ
#         if not approved_genres or not dates:
#             return
# 
#         # format approved genres into a quoted string
#         approved_str = ", ".join(f"'{g}'" for g in sorted(approved_genres))
#         # output key and counts
#         yield [title, approved_str], [len(dates), len(all_genres)]
# 
#     #I get from my first reducer a tuple of title and approved genres(in short i wrote appgenre)
#     #also i get counts of dates and genres as written in q1
#     def score_mapper(self, title_appgerne ,counts):
#       date_counts, genre_counts = counts
#       total_score = date_counts + genre_counts
#       #i don't want to get back the approved genre and obly the title itself
#       yield None ,(title_appgerne[0], total_score)
# 
#     def best_score(self, _, title_scores):
#       best_title, best_score = max(title_scores, key=lambda x: x[1])
#       yield best_title, best_score
# 
# 
# 
# 
# if __name__ == '__main__':
#     MRApproved.run()
# 
#

!python hw1_mrA2_322479387_207039199_208197814.py 440k_data.csv -q